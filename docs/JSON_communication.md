
# JSON Communication

Everything also contains an ID!

	{
		"ID": 123,
		"type": ...,
		"data": ...
	}

## Errors

If an error occurs and the requested operation did not complete; the backend will send a message back like this:

	{
		"ID": 123,
		"type": "error",
		"data": {
			"short": "short string to be interpreted by frontend",
			"long": "long string for dialog etc"
		}
	}

## User Auth

### Signup **risky**

Client message:

	{
		"type": "signup",
		"data": {
			"email": "...",
			"password": "123",
			"first_name": ...,
			"last_name": ...,
		}
	}

Server response (Succes):

	{
		"type": "signup",
		"data": {
			"status": "success",
			"UID": 1
		}
	}

Server response (Fail):

	{
		"type": "signup",
		"data": {
			"status": "failure"
			"reason": "email_taken"
		}
	}

### Login **risky**

Client message:

	{
		"type": "login",
		"data": {
			"email": "abc",
			"password": "123"
		}
	}

Server response (Fail):

	{
		"type": "login",
		"data": {
			"status": "failure"
			"reason": "email_unknown" || "wrong_password"
		}
	}

Server response (Success):

	{
		"type": "login",
		"data": {
			"status": "success",
			"session": "78SD451xdsf487scxg4i7ojkh14q12z4c1f4e87rhj4",
			"user": {
					"UID": 123,
					"email": "douglas.adams@hotmail.com",
					"first_name": "Douglas",
					"last_name": "Adams"
			}
		}
	}

While logged in, the cookie (=session) has been set, which the server can get from the headers.
42
### Logout

Client message:

	{
		"type": "logout"
	}

No server response is needed.

## Getting, adding, deleting data

The `"what"` attribute is the class of the object you are dealing with. Example: `Sensor` or `User`.

In the following `"ID"` refers to either `"SID"` (for Sensors) or `"UID"` (for Users) and so on.

In some cases, there is a `"for"` attribute. This is used to refer to objects related to some other object. An example is adding a value for a given sensor.
It looks like this:

	{
		...
		"for": {
			"what": "Sensor",
			"SID": 123,
		}
		...
	}

You have to add a `"for"` attribute when it is not clear what you mean. For example, when adding values the definition is not enough to know for which sensor the value holds.
"Bigger" datatypes will usually store ID's of other object they refer to (e.g. a Sensor has a `"UID"` attribute).

### Adding

Message:

	{
		"type": "add",
		"what": <object class>,
		"data": <definition without ID>
	}

Response (Success):

	{
		"type": "add",
		"what": <object class>,
		"data": <definition with ID>
	}

Response (Failure): normal error message


When adding a value, you need to specify for which sensor it is.

### Deleting

Message:

	{
		"type": "delete",
		"what": <object class>,
		"data": {
			"ID": <ID of what you want to delete>,
		}
	}

Response (Success):

	{
		"type": "delete",
		"data": {
			"status": "success"
		}
	}

Response in case of failure is a normal error message.

Again, for a value you need a `"for"` attribute.

### Getting

#### Getting a single object by ID

Message:

	{
		"type": "get",
		"what": <object class>,
		"data": {
			"ID": <ID>,
		}
	}

Response (Success):

	{
		"type": "get",
		"what": <object class>,
		"data": {
			<entire definition>
		}
	}

Response (Fail): normal error message

So far there is no way to get a single Value, and therefore no `"get"` message will need a `"for"` attribute (this may change in the future).

#### Getting multiple objects

The `"where"` part is optional.

Message:

	{
		"type": "get_all",
		"what": "Sensor",
		"for": {
			"what": "User",
			"UID": "123",
		}
		"where": [{
			"field": "Value.data",
			"op": "gt" //Greater than,lower than etc...,
			"value": "...",
		}, ...]
	}

Response:

(Note, `"data"` is an array here)

	{
		"type": "get_all",
		"what": "Sensor",
		"for": {
			"what": "User",
			"UID": "123",
		}
		"data": [
			<definition 1>,
			<definition 2>,
			...
			]
	}

There can be failure, but it can also happen that the server returns an empty list. This is not considered an error.

Another example for Data:

Message:

	{
		"type": "get_all",
		"what": "Value",
		"for": {
			"what": "Sensor",
			"SID": "123",
		}
	}

Response:

	{
		"type": "get_all",
		"what": "Value",
		"for": {
			"what": "Sensor",
			"SID": "123",
		}
		"data": [
			[1234567890, 3.1415],
			[1234567891, 3.1546],
			[1234567891, 3.7460],
			...
		]
	}

### Editing

Message:

	{
		"type": "edit",
		"what": <class>,
		"data": {
			<new definition WITH ID>
		}
	}

There can be a `"for"` attribute here.

Response (Success):

	{
		"type": "edit",
		"what": <object class>,
		"data": {
			"object": <entire definition with ID>		
		}
	}


Response (Failure): normal error message


## Definitions

More info can be found in JSON_definitions.rst, which is autogenerated. Only certain exceptions will be mentioned here.

#### Value

A value for a given sensor is encoded in JSON as a simple array (should be interpreted as a tuple):

	[1234567890, 12.457]

The first number is the amount of milliseconds since the UNIX epoch. In Linux you can get that value using `date +%s%3N` and in
Javascript you can simply construct a Date object with that number: `var d = new Date(1234567890)`. The second number is a real number.

A value is uniquely identified by the sensor and it's timestamp.

## Live updates

Frontend -> Backend

	{
		"ID": 123,
		"type": "register" / "unregister",
		"what": "<class>",
		"data": {
			"UID" / "SID": 123
		}
	}

Server responses can be of type: `live_add_ref`, `live_remove_ref`, `live_edit`, `live_delete`.

For now, registering on a user will also send updates on which sensors the user owns.

Closing the connection will unregister from any objects.

Apart from that you can also unregister from all objects:

	{
		"ID": 123,
		"type": "unregister_all",
		"what": "<class>",
	}


`edit` will simply send a new definition of the object.

## Live updates type

Todo: 

Edit in sensoren van location_LID, als _location != null moet je er de juiste locatie insteken.

### Add reference

Object A has a new reference to object B. (Usually this means that object A itself is new).

	{
		"type": "live_add_ref",
		"from": {
			"what": "<class name>",
			<Key of object A>: 
		}
		"to": {
			"what": <class of Object B>, // update all html references of this object
			<Key of object B>: 123,
		},
		"data": <entire definition with ID of object A> // Add this object to the cache
	}

Example:

	{
		"type": "live_add_ref",
		"for": {
			"what": User,
			"UID": 1,
		},
		"what": "Location",
		"data": {"LID": 4, "user_UID": 1, ...}
	}

In the example, there is a new location added to the database, but the reason you are notified of this, is because the new location refers to the user in some attribute (in this case, the "user_UID" attribute).

You will only receive such updates on objects you registered on (in this case, the user).


### Remove reference

	{
		"type": "live_remove_ref",
		"from": {
			"what": "<class name>",
			<Key of object A>: 
		},
		"to": {
			"what": <class of Object B>, // update all html references of this object
			<Key of object B>: 123,
		}
	}

This means that object A no longer refers to object B.

### Edit

	{
		"type": "live_edit",
		"what": "<class name>",
		"data": <entire definition with ID of object>
	}

### Delete

	{
		"type": "live_delete",
		"what": "<class name>",
		"data": {
			"SID"/"UID"/... : ...,
		}
	}
