
# Notes to understand ElecSim

First of all, the quality of the code is very bad. Big chunks of commented out VBA code remain, and most naming conventions (like prefixing variables with their type, 'i' for integer and so on) are only followed half of the time. I have tried to provide extensive annotations for the most important functions. I've also autopep8'ed all the files. I removed about 2/3 of the files originally provided, because they don't do anything useful. In fact, `src/occprob.py` will crash the python parser. Not the program itself, not even the interpreter, the parser. (The reason for this are the nested lists).

But hey, "code was based on excel VBA script, so no judgement! ;-)".

The main function calls (in generate mode), the `generate_sensor_data` function (`main.py`, L151):

	def generate_sensor_data(config_file: str, household: int, from_date: datetime, to_date: datetime, outputfile: str)

Which opens the file `config_file`, reads it in as json, selects the `household`-th house, and starts generating data to the file `outputfile`.

The data itself is generated by this function, in (`src/generate_data.py`, L18):

	def generate_data_range(iResidents: int, Dwell: List[str], iIrradianceThreshold: int, iRandomHouse: int, from_date: datetime.datetime, to_date: datetime.datetime) -> List[List[Union[str, float]]]:

`Dwell` is a list of strings, but they can only be `"YES"` or `"NO"`. I have no idea what the name is supposed to mean.

Which then creates a list of days (without looking to times). For every one of these days, it calls this function to generate a number of occupants (`ResultofOccupancySim`) (`src/occsimread.py`, L36):

	def OccupanceSim(iResidents: int, bWeekend: bool)

This function will search for files in `../data/`, modify this if you want to start it from somewhere else.

It then creates the actual data using this function in (`src/generate_data.py`, L57):

	def generate_date_single_day(Dwell: List[str], ResultofOccupancySim: int, bWeekend: bool, iMonth: int, iIrradianceThreshold: int, iRandomHouse: int, addHeader: bool) -> List[List[Union[str, float]]]

The data is then filtered in `generate_data_range` by minute.

